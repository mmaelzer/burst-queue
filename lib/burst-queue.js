// Generated by CoffeeScript 1.3.3
(function() {
  var BurstQueue;

  BurstQueue = (function() {
    var _maxItems, _queue;

    _queue = new Array();

    _maxItems = 0;

    function BurstQueue(period, itemsPerPeriod) {
      this.counter = 0;
      this.availableCalls = _maxItems = itemsPerPeriod != null ? itemsPerPeriod : _maxItems;
      setInterval(this.process, period);
    }

    BurstQueue.prototype.add = function(functions) {
      var fn, ids, _i, _len;
      if (Object.prototype.toString.apply(functions) === '[object Array]') {
        ids = new Array();
        for (_i = 0, _len = functions.length; _i < _len; _i++) {
          fn = functions[_i];
          if (this.availableCalls > 0) {
            this.availableCalls--;
            fn();
          } else {
            _queue.push({
              id: this.counter,
              fn: fn
            });
          }
          ids.push(this.counter++);
        }
        return ids;
      } else {
        if (this.availableCalls > 0) {
          this.availableCalls--;
          functions();
        } else {
          _queue.push({
            id: this.counter,
            fn: functions
          });
        }
        return this.counter++;
      }
    };

    BurstQueue.prototype.clear = function() {
      _queue.length = 0;
    };

    BurstQueue.prototype.enqueued = function() {
      return _queue.length;
    };

    BurstQueue.prototype.process = function() {
      var index, _i, _ref;
      if (_queue.length < 1) {
        this.availableCalls = _maxItems;
        return;
      }
      for (index = _i = 0, _ref = _queue.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; index = 0 <= _ref ? ++_i : --_i) {
        _queue[index].fn();
        if ((index + 1) >= _maxItems) {
          break;
        }
      }
      _queue.splice(0, index + 1);
      if (index < _maxItems) {
        return this.availableCalls = _maxItems - (index + 1);
      }
    };

    BurstQueue.prototype.remove = function(id) {
      var index, success, _i, _ref;
      if (_queue.length < 1) {
        return false;
      }
      success = false;
      for (index = _i = 0, _ref = _queue.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; index = 0 <= _ref ? ++_i : --_i) {
        if (_queue[index].id === id) {
          success = true;
          break;
        }
      }
      if (success) {
        _queue.splice(index, 1);
      }
      return success;
    };

    return BurstQueue;

  })();

  module.exports = BurstQueue;

}).call(this);
